### <a name="rule-5.5"></a> 5.5. Для бесконечных списков (infinite scroll) используйте [Relay Cursor Connections Specification](https://facebook.github.io/relay/graphql/connections.htm).

У пагинации есть недостаток, когда добавляются или удаляются элементы, то при переходе на следующую страницу вы можете столкнуться с проблемами:

- under-fetching — это когда в начале списка удаляется элемент, и при переходе на следующую страницу клиент пропускает запись, которая "убежала" на предыдущую страницу
- over-fetching — это когда добавляются новые записи в начало списка, и при переходе на следующую страницу клиент повторно видит записи которые были на предыдущей странице

Для решения этой проблемы Facebook разработал спецификацию [Relay Cursor Connections Specification](https://facebook.github.io/relay/graphql/connections.htm). Она идеально подходит для создания бесконечных (infinite scroll) списков. А коль есть спецификация, то значит есть некий стандарт которому может следовать команда разработчиков и не изобретать велосипеды.

Правда вид GraphQL-запросов у infinite scroll не очень, на первый взгляд он выглядит непонятно и требует объяснения для клиентов:

```graphql
{
  articles(first: 10, after: "opaqueCursor") {
    edges {
      cursor
      node { # только на 3-уровне вложенности получаем данные записи
        id
        name
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}
```

Поэтому если у вас есть возможность для ваших клиентов помимо Infinite Scroll передать еще и обычную пагинацию – то они вам только спасибо скажут за возможность выбора в получении данных.
