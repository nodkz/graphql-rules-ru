## 2. Правила типов

GraphQL по спецификации содержит всего 5 скалярных типов – `String` (строка), `Int` (целое число), `Float` (число с точкой), `Boolean` (булевое значение), `ID` (строка с уникальным идентификатором). Все эти типы легко передаются через JSON и доступны на любом языке программирования.

Но когда речь заходит о каком-то скалярном типе не входящего в синтаксис JSON, например `Date`. То тут уже необходимо бэкендеру самостоятельно определяться с форматом данных, чтоб их можно было сериализовать и передать клиенту через JSON. А также получить значение этого типа от клиента и обратно десериализовать его на сервере.

В таких случаях GraphQL позволяет создавать свои кастомные скалярные типы. О том как это делается [написано здесь](../types/README.md#custom-scalar-types).

### <a name="rule-2.1"></a> 2.1. Используйте кастомные скалярные типы, если вы хотите объявить поля или аргументы с определенным семантическим значением.

Если поле возвращает тип `String`, то клиентам вашего API нет возможности понять имеет ли это поле какое-то семантическое значение, какое-нибудь ограничение. Например, с помощью типа `String` вы можете передавать обычный текст, HTML, строку длиной в 255 символов, строку в base64, дату или любое другое хитрое значение.

Для того чтобы сделать ваше АПИ более прозрачным для команды, создавайте кастомные скалярные типы. Например: `HTML`, `String255`, `Base64`, `DateString`.

Бэкендерам это позволит единожды написать методы валидации, (де-)сериализации для кастомных скалярных типов и избежать дублирование кода в резолверах.

Фронтендерам это позволит написать компоненты для отображения или ввода данных и явно переиспользовать их для конкретных скалярных типов.

```diff
type Article {
  id: ID!
-  description: String
+  description: HTML
}
```

В таком случае легче понимать, что в поле `description` прилетает html-документ и скорее всего его не нужно эскейпить при отображении в браузере, а показывать как есть.

### <a name="rule-2.2"></a> 2.2. Используйте Enum для полей, которые содержат определенный набор значений.

Частенько в схемах встречаются поля, которые содержат определенный набор значений. Например: `пол`, `статус заявки`, `код страны`, `вид оплаты`. Использовать просто тип `String` или `Int` в таких случаях никоим образом не помогает вашим клиентам понять, какие значения могут быть получены.

Конечно доступные значения можно описать в документации. Но я не вижу смысла этого делать, когда в GraphQL есть тип `Enum` — [читать подробнее](../types/README.md#enumeration-types).

Значения полей с типом `Enum` проверяются на этапе валидации запроса. А также они могут проверяться на этапе разработки линтерами и статическими анализаторами. Это на порядок полезнее и безопаснее, чем тупо перечислять значения в документации.

```diff
type User {
-  status: String # BAD
+  status: StatusEnum # GOOD
}

+ enum StatusEnum {
+   ACTIVE
+   PENDING
+   REJECTED
+ }
```