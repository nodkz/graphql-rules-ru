### <a name="rule-6.4"></a> 6.4. Mutations should clearly describe all the mandatory arguments, there should be no options either-either.

There are tasks when it is necessary to take different input parameters depending on certain input values. The problem is that in this case, it is necessary to specify the input parameters as optional, which can lead to errors, because the client does not know for sure which parameters are required in this or that case.

К примеру ваше АПИ позволяет отправить разные письма с помощью мутации `sendEmail(type: PASSWORD_RESET, params: JSON)`. Для того чтобы выбрать шаблон, вы передаете Enum аргумент с типом письма и для него передаете какие-то параметры.

Проблема такого подхода в том, что клиент заранее точно не знает какие параметры необходимо передать для того или иного типа писем. К тому же, если в будущем проводить рефакторинг схемы, то статическая типизация нам не позволит отловить ошибки на клиенте.

Лучше разбивать мутации на несколько штук с жестким описанием аргументов. Например: `sendEmailPasswordReset(login: String!, note: String)`. При этом не забываем аргументы помечать как обязательные, если без них операция не отработает.

Также бывают ситуации, когда вы обязаны передать либо один аргумент, либо другой. К примеру, мы можем отправить письмо по сбросу пароля если укажут login или email – `sendResetPassword(login: String, email: String)`.

В таком случае мы не можем оба аргумента в нашей мутации сделать обязательными. О том что не передан обязательный аргумент, мы узнаем только в рантайме. Да и фронтендеру будет не сразу понятно, что надо передавать либо `login`, либо `email`. А что будет если передать оба аргумента от разных пользователей?

Для решения этой проблемы просто заводится две мутации, где жестко расписаны обязательные аргументы:

```diff
type Mutation {
-  sendResetPassword(login: String, email: Email)
+  sendResetPasswordByLogin(login: String!)  # login NonNull
+  sendResetPasswordByEmail(email: Email!)   # email NonNull
}
```

Не экономьте на мутациях и старайтесь избегать слабой типизации.

Если вы только начинаете знакомство с graphQL, Вы могли бы подумать, что проблему можно решить с помощью union инпутов, однако, их в graphQL еще не завезли. В официальном репозитории graphQL ведется обсуждение добавления union инпутов, за которым вы можете следить [здесь](https://github.com/facebook/graphql/issues/488). Вы должны понимать, что после добавления union инпутов некоторые схожие задачи будет правильнее решать с их помощью. В обсуждении вы можете ознакомиться с примерами задач от разработчиков, которые нуждаются в добавлении union инпутов.